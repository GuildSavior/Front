import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router, ActivatedRoute } from '@angular/router';
import { trigger, transition, style, animate } from '@angular/animations';
import { UsersService } from '../../../services/users/users.service';
import { DiscordAuthService } from '../../../services/discordAuth/discord-auth.service';
import { AuthService } from '../../../services/auth.service';
import { PlanService } from '../../../services/plan/plan.service';
import { PlayerService } from '../../../services/player/player.service';
import { User } from '../../../models/user.model'; // ‚úÖ CORRIGER le chemin
import { Player, PlayerClass } from '../../../models/player.model'; // ‚úÖ CORRIGER le chemin
import { FormsModule } from '@angular/forms';
import { environment } from '../../../../environments/environment';

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [CommonModule, FormsModule], 
  templateUrl: './dashboard.component.html',
  styleUrls: ['./dashboard.component.scss'],
  animations: [
    trigger('fadeSlide', [
      transition(':enter', [
        style({ opacity: 0, transform: 'translateY(-10px)' }),
        animate('250ms cubic-bezier(0.4,0.2,0.2,1)', 
          style({ opacity: 1, transform: 'translateY(0)' }))
      ]),
      transition(':leave', [
        animate('200ms', style({ opacity: 0, transform: 'translateY(-10px)' }))
      ])
    ])
  ]
})
export class DashboardComponent implements OnInit {
  showSensitive = false;
  userService = inject(UsersService);
  discordAuthService = inject(DiscordAuthService);
  authService = inject(AuthService);
  planService = inject(PlanService);
  playerService = inject(PlayerService);
  route = inject(ActivatedRoute);
  router = inject(Router);
  
  // ‚úÖ NOUVELLES propri√©t√©s pour le profil joueur
  hasPlayerProfile = false;
  isEditingPlayer = false;
  isSubmittingPlayer = false;
  
  // ‚úÖ Formulaire joueur modifi√©
  playerForm: {
    name: string;
    level: number;
    class: PlayerClass;
  } = {
    name: '',
    level: 1,
    class: 'dps'
  };

  // ‚úÖ Profil joueur actuel
  currentPlayer: any = null;

  player: Player = {
    classe: 'dps',
    events_joined: 0
  };

  // ‚úÖ CORRIGER: Utiliser null au lieu d'un objet vide
  user: User | null = null;
  notification: string | null = null;
  isLoading = true; // ‚úÖ AJOUTER pour l'√©tat de chargement
  environment: any;

  // ‚úÖ NOUVEAU: Propri√©t√© pour l'upgrade
  isUpgrading = false;

  ngOnInit() {
    // ‚úÖ Debug en d√©veloppement
    if (environment.enableDebugLogs) {
      console.log('üîß DashboardComponent - Initialisation');
    }

    // ‚úÖ AFFICHER l'environnement actuel
    console.log('üåç ENVIRONNEMENT ACTUEL:', environment.environmentName);
    console.log('üåç API URL:', environment.apiUrl);
    console.log('üåç Production:', environment.production);
    console.log('üåç Debug activ√©:', environment.enableDebugLogs);
    
    // ‚úÖ V√©rifier d'abord si on est connect√©
    if (!this.authService.isLoggedIn()) {
      if (environment.enableDebugLogs) {
        console.log('üîß Dashboard - Utilisateur non connect√©, redirection vers Discord');
      }
      localStorage.setItem('pendingDashboardSuccess', '1');
      this.discordAuthService.loginWithDiscord();
      return;
    }

    // ‚úÖ CORRIGER: Extraire user depuis la r√©ponse API
    this.userService.getUserInformation().subscribe({
      next: (response: any) => {
        if (environment.enableDebugLogs) {
          console.log('üîß Dashboard - R√©ponse API compl√®te:', response);
          console.log('üîß Status:', response.status);
          console.log('üîß User dans la r√©ponse:', response.user);
        }

        // ‚úÖ CORRIGER: Extraire l'utilisateur depuis response.user
        if (response.status === 'success' && response.user) {
          this.user = response.user; // ‚úÖ UTILISER response.user au lieu de response
          
          if (environment.enableDebugLogs) {
            console.log('üîß Username:', this.user?.username);
            console.log('üîß Avatar:', this.user?.avatar);
            console.log('üîß Discord ID:', this.user?.discord_id);
            console.log('üîß Is Premium:', this.user?.is_premium);
            console.log('üîß Guild ID:', this.user?.guild_id);
          }
        } else {
          console.error('‚ùå Structure de r√©ponse inattendue:', response);
          this.user = null;
        }
        
        this.isLoading = false;
        
        // ‚úÖ FORCER le changement de d√©tection
        setTimeout(() => {
          if (environment.enableDebugLogs) {
            console.log('üîß this.user final:', this.user);
            console.log('üîß this.userName getter:', this.userName);
            console.log('üîß this.userAvatar getter:', this.userAvatar);
          }
        }, 100);
        
        this.loadPlayerProfile();
        this.handleQueryParams();
      },
      error: (error) => {
        console.error('‚ùå Erreur r√©cup√©ration utilisateur:', error);
        console.error('‚ùå Status:', error.status);
        console.error('‚ùå Message:', error.message);
        console.error('‚ùå Error complet:', error);
        
        this.isLoading = false;
        
        if (error.status === 401 || error.status === 403) {
          if (environment.enableDebugLogs) {
            console.log('üîß Dashboard - Token invalide, redirection vers Discord');
          }
          localStorage.setItem('pendingDashboardSuccess', '1');
          this.discordAuthService.loginWithDiscord();
        } else {
          this.notification = '‚ùå Erreur lors du chargement des donn√©es';
          setTimeout(() => this.notification = null, 4000);
        }
      }
    });
  }

  // ‚úÖ NOUVELLE m√©thode pour g√©rer les param√®tres de requ√™te
  private handleQueryParams() {
    this.route.queryParams.subscribe(params => {
      if (params['payment'] === 'success') {
        this.notification = 'Abonnement premium activ√© avec succ√®s ! üéâ';
        // Nettoyer l'URL sans recharger la page
        this.router.navigate(['/dashboard'], { 
          queryParams: {},
          replaceUrl: true 
        });
        setTimeout(() => this.notification = null, 5000);
      }
      
      if (params['loginSuccess'] === '1') {
        this.notification = 'Connexion r√©ussie ! Bienvenue üëã';
        this.router.navigate(['/dashboard'], { 
          queryParams: {},
          replaceUrl: true 
        });
        setTimeout(() => this.notification = null, 4000);
      }
    });
  }

  // ‚úÖ Charger le profil joueur
  loadPlayerProfile() {
    if (environment.enableDebugLogs) {
      console.log('üîß Dashboard - Chargement du profil joueur');
    }

    this.playerService.getMyProfile().subscribe({
      next: (response) => {
        if (response.success && response.player) {
          this.currentPlayer = response.player;
          this.hasPlayerProfile = true;
          this.playerForm = {
            name: response.player.name,
            level: response.player.level,
            class: response.player.class
          };
          this.player.classe = response.player.class;
          
          if (environment.enableDebugLogs) {
            console.log('‚úÖ Profil joueur charg√©:', this.currentPlayer);
          }
        } else {
          this.hasPlayerProfile = false;
          if (environment.enableDebugLogs) {
            console.log('‚ÑπÔ∏è Aucun profil joueur trouv√©');
          }
        }
      },
      error: (error) => {
        this.hasPlayerProfile = false;
        if (environment.enableDebugLogs) {
          console.log('‚ÑπÔ∏è Pas de profil joueur encore cr√©√©');
        }
      }
    });
  }

  startEditPlayer() {
    this.isEditingPlayer = true;
    if (this.hasPlayerProfile && this.currentPlayer) {
      this.playerForm = {
        name: this.currentPlayer.name,
        level: this.currentPlayer.level,
        class: this.currentPlayer.class
      };
    }
  }

  cancelEditPlayer() {
    this.isEditingPlayer = false;
    if (this.hasPlayerProfile && this.currentPlayer) {
      this.playerForm = {
        name: this.currentPlayer.name,
        level: this.currentPlayer.level,
        class: this.currentPlayer.class
      };
      this.player.classe = this.currentPlayer.class;
    } else {
      this.playerForm = {
        name: '',
        level: 1,
        class: 'dps'
      };
      this.player.classe = 'dps';
    }
  }

  savePlayerProfile() {
    if (!this.playerForm.name.trim()) {
      this.notification = '‚ùå Le nom du personnage est obligatoire';
      setTimeout(() => this.notification = null, 3000);
      return;
    }

    if (this.playerForm.level < 1 || this.playerForm.level > 55) {
      this.notification = '‚ùå Le niveau doit √™tre entre 1 et 55';
      setTimeout(() => this.notification = null, 3000);
      return;
    }

    this.isSubmittingPlayer = true;

    this.playerService.createOrUpdateProfile(this.playerForm).subscribe({
      next: (response) => {
        if (response.success) {
          this.currentPlayer = response.player;
          this.hasPlayerProfile = true;
          this.isEditingPlayer = false;
          this.player.classe = this.playerForm.class;
          
          this.notification = `‚úÖ ${response.message}`;
          setTimeout(() => this.notification = null, 4000);
          
          if (environment.enableDebugLogs) {
            console.log('‚úÖ Profil sauvegard√©:', this.currentPlayer);
          }
        }
        this.isSubmittingPlayer = false;
      },
      error: (error) => {
        console.error('‚ùå Erreur sauvegarde:', error);
        this.notification = error.error?.message || '‚ùå Erreur lors de la sauvegarde';
        setTimeout(() => this.notification = null, 4000);
        this.isSubmittingPlayer = false;
      }
    });
  }

  deletePlayerProfile() {
    if (!confirm('√ätes-vous s√ªr de vouloir supprimer votre profil joueur ? Cette action est irr√©versible.')) {
      return;
    }

    this.playerService.deleteProfile().subscribe({
      next: (response) => {
        if (response.success) {
          this.currentPlayer = null;
          this.hasPlayerProfile = false;
          this.isEditingPlayer = false;
          this.playerForm = {
            name: '',
            level: 1,
            class: 'dps'
          };
          this.player.classe = 'dps';
          this.notification = '‚úÖ Profil joueur supprim√© avec succ√®s';
          setTimeout(() => this.notification = null, 4000);
        }
      },
      error: (error) => {
        console.error('‚ùå Erreur suppression:', error);
        this.notification = '‚ùå Erreur lors de la suppression';
        setTimeout(() => this.notification = null, 4000);
      }
    });
  }

  // ‚úÖ CORRIGER les m√©thodes existantes pour v√©rifier si user existe
  isPremium(): boolean {
    if (!this.user) return false;
    return this.planService.isPremiumActive(this.user);
  }

  getSubscriptionInfo() {
    if (!this.user) return null;
    return this.planService.getSubscriptionDetails(this.user);
  }

  getPremiumBadgeClass(): string {
    if (!this.user) return '';
    return this.planService.getPremiumBadgeClass(this.user);
  }

  goToGuild() {
    this.router.navigate(['/guild']);
  }

  // ‚úÖ AJOUTER des getters pour le template
  get userName(): string {
    const name = this.user?.username || 'Utilisateur';
    if (environment.enableDebugLogs) {
      console.log('üîß userName getter appel√©, user:', this.user, 'name:', name);
    }
    return name;
  }

  get userAvatar(): string {
    const avatar = this.user?.avatar || '/assets/default-avatar.png';
    if (environment.enableDebugLogs) {
      console.log('üîß userAvatar getter appel√©, user:', this.user, 'avatar:', avatar);
    }
    return avatar;
  }

  get totalDkp(): number {
    const dkp = this.user?.total_dkp || 0;
    if (environment.enableDebugLogs) {
      console.log('üîß totalDkp getter appel√©, user:', this.user, 'dkp:', dkp);
    }
    return dkp;
  }

  get hasGuild(): boolean {
    const hasGuild = !!this.user?.guild_id;
    if (environment.enableDebugLogs) {
      console.log('üîß hasGuild getter appel√©, user:', this.user, 'hasGuild:', hasGuild);
    }
    return hasGuild;
  }

  // ‚úÖ AJOUTER m√©thode de d√©connexion
  logout() {
    if (environment.enableDebugLogs) {
      console.log('üîß Dashboard - D√©connexion demand√©e');
    }
    
    // ‚úÖ Plus besoin de logoutAndRedirect(), juste logout()
    this.authService.logout();
  }

  // ‚úÖ NOUVEAU: M√©thode upgradeToPremium (identique √† guild)
  upgradeToPremium() {
    console.log("Lancement de l'achat premium depuis le dashboard");
    
    this.isUpgrading = true;
    
    const token = this.getCookie('auth_token');
    
    if (!token) {
      console.warn('Utilisateur non connect√©, redirection vers Discord');
      localStorage.setItem('pendingPremium', '1');
      
      // Redirection vers la page d'accueil pour se connecter
      this.router.navigate(['/home']);
      
      this.isUpgrading = false;
      return;
    }

    console.log("Utilisateur connect√©, lancement de Stripe");
    this.launchStripe();
  }

  // ‚úÖ NOUVEAU: M√©thode pour lancer Stripe
  private launchStripe() {
    const token = this.getCookie('auth_token');
    
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };

    // ‚úÖ Utiliser fetch au lieu de HttpClient pour √©viter les imports
    fetch(`${environment.apiUrl}/stripe/create-checkout-session`, {
      method: 'POST',
      headers: headers,
      credentials: 'include',
      body: JSON.stringify({})
    })
    .then(response => response.json())
    .then(data => {
      if (data.url) {
        console.log('‚úÖ Session Stripe cr√©√©e, redirection...');
        
        // ‚úÖ Message de feedback
        this.notification = 'üöÄ Redirection vers le paiement s√©curis√©...';
        
        // Redirection vers Stripe
        window.location.href = data.url;
      } else {
        console.error('‚ùå Pas d\'URL de redirection dans la r√©ponse Stripe');
        this.notification = '‚ùå Erreur lors de la cr√©ation de la session de paiement.';
        this.isUpgrading = false;
        setTimeout(() => this.notification = null, 4000);
      }
    })
    .catch(error => {
      console.error('‚ùå Erreur Stripe:', error);
      this.notification = '‚ùå Erreur lors de la connexion au service de paiement.';
      this.isUpgrading = false;
      setTimeout(() => this.notification = null, 4000);
    });
  }

  // ‚úÖ NOUVEAU: M√©thode getCookie
  private getCookie(name: string): string | null {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) {
      return parts.pop()?.split(';').shift() || null;
    }
    return null;
  }

  // M√©thode pour obtenir le nom d'affichage de la classe
  getClassDisplayName(classKey: string): string {
    const classNames: { [key: string]: string } = {
      'tank': 'üõ°Ô∏è Tank',
      'dps': '‚öîÔ∏è DPS', 
      'support': 'ü©π Support',
      'range': 'üèπ Range',
      'mage': 'üîÆ Mage'
    };
    return classNames[classKey] || classKey;
  }

  // M√©thodes de navigation (√† adapter selon tes routes)
  goToEvents() {
    this.router.navigate(['/events']);
  }

  goToSettings() {
    this.router.navigate(['/auctions']);
  }
}
